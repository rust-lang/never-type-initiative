<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Never Type initiative</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html">üëã Welcome</a></li><li class="chapter-item "><a href="updates.html">‚úèÔ∏è Updates</a></li><li class="chapter-item "><a href="CHARTER.html">üìú Charter</a></li><li class="chapter-item "><a href="evaluation.html">üî¨ Evaluation</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="evaluation/issues.html">PRs/Issues</a></li><li class="chapter-item "><a href="evaluation/no-inference-changes.html">No inference changes</a></li></ol></li><li class="chapter-item "><a href="explainer.html">üìö Explainer</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="explainer/conditional-fallback-v1.html">Conditional Fallback v1</a></li></ol></li><li class="chapter-item "><a href="RFC.html">‚ú® RFC</a></li><li class="chapter-item "><a href="FAQ.html">üòï FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Never Type initiative</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/never-type-initiative" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="never-type-initiative"><a class="header" href="#never-type-initiative">Never type initiative</a></h1>
<!--

 This is the template for creating an initiative in rust-lang. Be sure to go
 through all sections marked with `**FIX ME**`, and make sure that the text is
 correct, and feel free to replace/remove any part that's not relevant to
 your group.

 Steps to customize:

 * Edit CHARTER.md
 * Replace placeholder text (see below)
 * Remove references to "expermental" and "evaluation" unless you need them

  All of the text across all of the initial files uses the same group of
 variables to allow for easy search and replace. They are listed below.

 Example sed command: `sed -i '' 's/{{INITIATIVE_NAME}}/Inline ASM/g' ./**/*.md`
 *Note* you need `-i ''` on macOS and just `-i` on Linux.

 * {{INITIATIVE_NAME}} -> The display name of your group e.g. "Inline ASM".
 * {{INITIATIVE_SLUG}} -> The url slug name of your group used for
   `rust-lang/team` and repo name. e.g. "pg-inline-asm".
 * {{CHAT_PLATFORM}} -> The name of your chat app e.g. "Zulip".
 * {{CHAT_LINK}} -> The hyperlink to your discussions on the chat app
   e.g. "https://rust-lang.zulipchat.com/#narrow/stream/216763-project-inline-asm".

To get your repo under rust-lang, file an infra issue:
https://github.com/rust-lang/infra-team/issues/new

-->
<p><img src="https://img.shields.io/badge/status-active-brightgreen.svg" alt="initiative status: active" /></p>
<h2 id="what-is-this"><a class="header" href="#what-is-this">What is this?</a></h2>
<p>This page tracks the work of the never type <a href="https://lang-team.rust-lang.org/initiatives.html">initiative</a>! To learn more about what we are trying to do, and to find out the people who are doing it, take a look at the <a href="./CHARTER.html">charter</a>.</p>
<h2 id="current-status"><a class="header" href="#current-status">Current status</a></h2>
<p>The following table lists of the stages of an initiative, along with links to the artifacts that will be produced during that stage.</p>
<table><thead><tr><th>Stage</th><th>State</th><th>Artifact(s)</th></tr></thead><tbody>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/proposal.html">Proposal</a></td><td>‚úÖ</td><td><a href="https://github.com/rust-lang/rust/issues/35121">Tracking issue</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/proposal.html">Experimental</a></td><td>ü¶Ä</td><td><a href="./evaluation.html">Evaluation</a></td></tr>
<tr><td></td><td></td><td><a href="./RFC.html">RFC</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/development.html">Development</a></td><td>üí§</td><td><a href="./explainer.html">Explainer</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/feature-complete.html">Feature complete</a></td><td>üí§</td><td>Stabilization report</td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/stabilized.html">Stabilized</a></td><td>üí§</td><td></td></tr>
</tbody></table>
<p>Key:</p>
<ul>
<li>‚úÖ -- phase complete</li>
<li>ü¶Ä -- phase in progress</li>
<li>üí§ -- phase not started yet</li>
</ul>
<h2 id="how-can-i-get-involved"><a class="header" href="#how-can-i-get-involved">How Can I Get Involved?</a></h2>
<ul>
<li>Check for 'help wanted' issues on this repository!</li>
<li>If you would like to help with development, please contact the <a href="./charter.html#membership">owner</a> to find out if there are things that need doing.</li>
<li>If you would like to help with the design, check the list of active <a href="./design-questions/README.html">design questions</a> first.</li>
<li>If you have questions about the design, you can file an issue, but be sure to check the <a href="./FAQ.html">FAQ</a> or the <a href="./design-questions/README.html">design-questions</a> first to see if there is already something that covers your topic.</li>
<li>If you are using the feature and would like to provide feedback about your experiences, please [open a &quot;experience report&quot; issue].</li>
<li>If you are using the feature and would like to report a bug, please open a regular issue.</li>
</ul>
<p>We also participate on <a href="https://rust-lang.zulipchat.com/#narrow/stream/259160-t-lang.2Fproject-never-type">Zulip</a>, feel free to introduce yourself over there and ask us any questions you have.</p>
<h2 id="building-documentation"><a class="header" href="#building-documentation">Building Documentation</a></h2>
<p>This repository is also an mdbook project. You can view and build it using the
following command.</p>
<pre><code>mdbook serve
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-updates"><a class="header" href="#-updates">‚úèÔ∏è Updates</a></h1>
<p>Lang-team initiatives give monthly updates. This section collects the updates from this initiative for posterity.</p>
<p>To add a new update:</p>
<ul>
<li>Create a new file <code>updates/YYYY-mmm.md</code>, e.g. <code>updates/2021-nov.md</code>
<ul>
<li>We recomend basing this on the <a href="https://github.com/rust-lang/initiative-template/tree/master/updates/template.md">update template</a></li>
</ul>
</li>
<li>Link it from the <code>SUMMARY.md</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-initiative_name-charter"><a class="header" href="#-initiative_name-charter">üìú {{INITIATIVE_NAME}} Charter</a></h1>
<!--
 Provide an introduction summarising the goals and motivation behind your
 initiative.
-->
<h2 id="proposal"><a class="header" href="#proposal">Proposal</a></h2>
<!--
Copy and paste the proposal into here. 

Feel free to move some elements, like design questions that came up,
into the approriate section.
-->
<h2 id="membership"><a class="header" href="#membership">Membership</a></h2>
<table><thead><tr><th>Role</th><th>Github</th></tr></thead><tbody>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/roles/owner.html">Owner</a></td><td><a href="https://github.com/ghost">ghost</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/roles/liaison.html">Liaison</a></td><td><a href="https://github.com/ghost">ghost</a></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-evaluation"><a class="header" href="#-evaluation">üî¨ Evaluation</a></h1>
<blockquote>
<p>The <em>evaluation</em> surveys the various design approaches that are under consideration.
It is not required for all initiatives, only those that begin with a problem statement
but without a clear picture of the best solution. Often the evaluation will refer to topics
in the <a href="./design-discussions.html">design-discussions</a> for more detailed consideration.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prsissues"><a class="header" href="#prsissues">PRs/Issues</a></h1>
<p>This is intended to give a relatively quick link list to relevant issues/PRs or
individual comments, for possible referencing/inclusion elsewhere.</p>
<h1 id="necessity-of-fallback-changes"><a class="header" href="#necessity-of-fallback-changes">Necessity of fallback changes</a></h1>
<p>Canonical example of inference failure with no-inference-change scenario.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct E;

impl From&lt;!&gt; for E {
    fn from(_: !) -&gt; E {
        E
    }
}

#[allow(unreachable_code)]
fn foo(never: !) {
    &lt;E as From&lt;!&gt;&gt;::from(never);  // Ok
    &lt;E as From&lt;_&gt;&gt;::from(never);  // Inference fails here
}
<span class="boring">}
</span></code></pre></pre>
<p>Discussion in:</p>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/67225">#67225</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/66757">#66757</a>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/66757#issuecomment-559771169">Possible options</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/66757#issuecomment-560571316">Necessity of fallback</a></li>
</ul>
</li>
</ul>
<h1 id="conditional-fallback"><a class="header" href="#conditional-fallback">Conditional fallback</a></h1>
<p>See <a href="evaluation/../explainer/conditional-fallback-v1.html">v1</a> explainer for the details of
the core algorithm.</p>
<p>Most of this code is implemented, gated on <code>never_type_fallback</code>,  landed in
<a href="https://github.com/rust-lang/rust/pull/88149">#88149</a> (primarily refactoring) and
<a href="https://github.com/rust-lang/rust/pull/88804">#88804</a> (most of the changes).</p>
<h1 id="pain-point--confusing-behavior"><a class="header" href="#pain-point--confusing-behavior">Pain point / confusing behavior</a></h1>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/66738">Closure return types are <code>()</code> even if body <code>!</code></a></li>
<li>Missing <code>From&lt;!&gt; for T</code>
<ul>
<li>Conflicts with <code>From&lt;T&gt; for &lt;T&gt;</code></li>
<li>After stabilizing <code>!</code>, a crate can add <code>From&lt;!&gt; for MyType</code> preventing a
std impl.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>This discusses the impact of just stabilizing <code>!</code> syntax and changing
<code>std::convert::Infallible</code> to be an alias for <code>!</code>. (That is, no inference
algorithm changes).</p>
<h1 id="regression-inference-failures"><a class="header" href="#regression-inference-failures">Regression: inference failures</a></h1>
<p>This leads to the regression identified in
<a href="https://github.com/rust-lang/rust/issues/66757">rust-lang/rust#66757</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct E;

impl From&lt;!&gt; for E {
    fn from(_: !) -&gt; E {
        E
    }
}

#[allow(unreachable_code)]
fn foo(never: !) {
    &lt;E as From&lt;!&gt;&gt;::from(never);  // Ok
    &lt;E as From&lt;_&gt;&gt;::from(never);  // Inference fails here
}
<span class="boring">}
</span></code></pre></pre>
<p>Without changes to type inference fallback, code such as the above with
<em>explicit</em> <code>!</code> type now fails to compile. This happens because with <code>!</code>, unlike
with <code>std::convert::Infallible</code>, <code>!</code> can coerce to any variable. That means that
the coercion from <code>!</code> to <code>_</code> <em>succeeds</em>, leading to the inference failure here,
as there's no constraint placed on the argument.</p>
<p>The coercion to inference variables is <em>in general</em> desirable, because of code
like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if foo {
    loop {}
}
<span class="boring">}
</span></code></pre></pre>
<p><code>if</code> expressions without else currently desugar such that the &quot;block&quot; is typed
at an inference variable (later eq'd with <code>()</code>), so the coercion to an inference
variable is necessary to make this work with the current compiler
implementation.  Further, changing the compiler to avoid this seems relatively
hard (FIXME: just how hard?). This regression is prominent enough that it makes
fully avoiding inference changes not possible.</p>
<h1 id="over-eager--fallback"><a class="header" href="#over-eager--fallback">Over-eager <code>()</code> fallback</a></h1>
<p>This leads to the painpoint (amongst others) identified in
<a href="https://github.com/rust-lang/rust/issues/66738">rust-lang/rust#66738</a>. This may
also be a regression in some cases if users start more explicitly writing <code>!</code> in
some places, though is not directly one at just stabilization time.</p>
<pre><pre class="playground"><code class="language-rust">fn magic&lt;R, F: FnOnce() -&gt; R&gt;(f: F) -&gt; F { f }

fn main() {
    let f2 = magic(|| loop {}) as fn() -&gt; !;
}
</code></pre></pre>
<p>The (presumed) expected behavior is that <code>loop {}</code>, having type <code>!</code>, means that
the closure above will have a return type of <code>!</code>. However, that's not what
actually happens: the closure's return type is set to an inference variable,
<code>?T</code>. Since expressions in the return position are coerced to the return type,
we end up with no requirement on the return type's inference variable. (The cast
does not participate in inference, generally). This means that the inference
variable is unconstrained and so falls back to <code>()</code>.</p>
<p>Note that this behavior is currently relied upon by some libraries. For example,
code like this is relatively common, which requires that closures return <code>()</code> or
<code>u32</code>. This means that if the fallback doesn't go to <code>()</code>, we will end up with
an error.</p>
<pre><pre class="playground"><code class="language-rust">trait Bar { }
impl Bar for () {  }
impl Bar for u32 {  }

fn foo&lt;R: Bar&gt;(_: impl Fn() -&gt; R) {}

fn main() {
    foo(|| panic!());
}
</code></pre></pre>
<p>Take a snippet from <a href="https://github.com/seanmonstar/warp/blob/v0.1.11/src/test.rs#L491-L496">warp 0.1.11</a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wr_rx.map_err(|()| {
    unreachable!(&quot;mpsc::Receiver doesn't error&quot;);
})
.forward(tx.sink_map_err(|_| ()))
.map(|_| ());
<span class="boring">}
</span></code></pre></pre>
<p>This code fails if the first closure is typed as <code>impl Fn(()) -&gt; !</code>, because
<code>forward</code> requires that <code>!: From&lt;()&gt;</code> (i.e., that the error types are
compatible). That impl is not currently available, so this code doesn't work
out.</p>
<p>This kind of interaction is relatively common, which makes changes to closure
return types that &quot;make sense&quot; at an intuitive level actually commonly result in
errors.</p>
<h1 id="unsizing-fails-due-to-eager-fallback"><a class="header" href="#unsizing-fails-due-to-eager-fallback">Unsizing fails due to eager fallback</a></h1>
<p>See <a href="https://github.com/rust-lang/rust/issues/49593">rust-lang/rust#49593</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: !) -&gt; Box&lt;dyn std::error::Error&gt; {
    Box::new(x)
}
<span class="boring">}
</span></code></pre></pre>
<p>This is essentially the same as the previous case, where we have <code>x</code> generate a
coercion at the function call site, meaning that we have <code>Box::&lt;?T&gt;::new(...)</code>
with no constraints on <code>?T</code>, which means <code>?T = ()</code> with no fallback changes.
Since <code>(): !Error</code>, this fails to compile.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-explainer"><a class="header" href="#-explainer">üìö Explainer</a></h1>
<blockquote>
<p>The &quot;explainer&quot; is &quot;end-user readable&quot; documentation that explains how to use the feature being deveoped by this initiative.
If you want to experiment with the feature, you've come to the right place.
Until the feature enters &quot;feature complete&quot; form, the explainer should be considered a work-in-progress.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="never-type-fallback-proposal"><a class="header" href="#never-type-fallback-proposal">Never type fallback proposal</a></h1>
<p>This is a proposal for an alternative scheme for never type fallback. This scheme, while not fully backwards compatible, sidesteps the problems we've encountered so far in attempting to stabilize the <code>!</code> type:</p>
<ul>
<li>Unsound type inference changes from changing fallback, as described in <a href="https://github.com/rust-lang/rust/issues/66173">#66173</a>. These problems result from changing the fallback from <code>()</code> to <code>!</code> for type variables wind up interacting with &quot;live code&quot;, resulting in <code>!</code> values being created.</li>
<li>Regressions from having no fallback at all, as described in <a href="https://github.com/rust-lang/rust/issues/67225">#67225</a> and <a href="https://github.com/rust-lang/rust/issues/66757">#66757</a>.</li>
</ul>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>The current fallback scheme is based on the concept of &quot;diverging&quot; type variables. In short, a <code>!</code> type can be coerced to any other type. But when it is inferred to an unknown type <code>?T</code> (a type variable), the way that we handle it is to create a <em>diverging</em> type variable <code>?D</code> and unify the two. Once type-checking is complete, we walk over any unbound type variables. If <code>?D</code> has not yet been unified with any concrete type (it may have been unified or related to other <em>general type variables</em>, but none of those type variables have yet been assigned a type), then it will &quot;fallback&quot; to a specified type. In current Rust, that type is <code>()</code>. The <code>!</code> type RFC proposed changing that fallback type to <code>!</code> (as part of introducing the concept of <code>!</code> as a standalone type). The idea behind this fallback is that since <code>?D</code> represents the type of an expression that is known to diverge, what actual type it is assigned to doesn't matter, since it can never affect live code. Unfortunately, this premise is false.</p>
<h3 id="bug-66173-unsoundness-introduced-by-changing-fallback-from--to-"><a class="header" href="#bug-66173-unsoundness-introduced-by-changing-fallback-from--to-">Bug 66173: Unsoundness introduced by changing fallback from <code>!</code> to <code>()</code></a></h3>
<p>As described in <a href="https://github.com/rust-lang/rust/issues/66173">#66173</a>, we have found in practice that the fallback of diverging type variables <em>can</em> impact the types assigned to live code. The most common problem involves match patterns. Consider the following pattern:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = match something() {
    pattern1 =&gt; Default::default(),
    pattern2 =&gt; panic!(&quot;...&quot;),
};
<span class="boring">}
</span></code></pre></pre>
<p>In a case like this, the type of the match is ultimately represented by a type variable <code>?M</code>. The first arm is assigned a type variable <code>?T</code> and the second arm (which panics) gets the type <code>!</code>. Both <code>?T</code> and <code>!</code> are coerced into <code>?M</code>:</p>
<pre><code>?T -&gt; ?M
! -&gt; ?M
</code></pre>
<p>The first coercion creates a subtyping relationship (<code>?T &lt;: ?M</code>) because the two types are unknown. The second coercion creates a diverging type variable <code>?D</code> and a subtyping relationship <code>?D &lt;: ?M</code>.</p>
<p>The problem now is that if <code>?D</code> falls back to <code>!</code>, then this winds up causing <code>?M</code> and <code>?T</code> to both be assigned the type <code>!</code>. In this <em>particular</em> example the result is a compilation error, because <code>Default</code> is not implemented for <code>!</code>, but in <a href="https://github.com/rust-lang/rust/issues/66173#issuecomment-574892360">other examples</a> the result was unsound execution.</p>
<p>This example prompted us to hold off on changing the fallback from <code>()</code> to <code>!</code>. The result is in some way no less surprising: the type of <code>Default::default</code> winds up falling back to <code>()</code>, rather than (say) requiring an explicit type annotation. However, at least using <code>()</code> didn't produce unsound behavior in previously sound code.</p>
<h3 id="bug-66757-regressions-introduced-by-not-changing-fallback"><a class="header" href="#bug-66757-regressions-introduced-by-not-changing-fallback">Bug 66757: Regressions introduced by NOT changing fallback</a></h3>
<p>Unfortunately, if we don't change the fallback to <code>!</code>, then we also trigger other sorts of regressions (at least if we want to also redefine the <code>Infallible</code> type in the stdlib). As described in <a href="https://github.com/rust-lang/rust/issues/66757">#66757</a>, the fundamental problem is that we <em>have</em> a <code>From&lt;!&gt;</code> impl for any type <code>E</code>, but we <em>don't</em> have a <code>From&lt;()&gt;</code> impl. So when we have code that requires <code>From&lt;?D&gt;</code> where <code>?D</code> is a diverging type variable, falling back to <code>!</code> is preferred.</p>
<p>This is related to the fact that <code>!</code> is in many cases the <em>right</em> fallback! If you have code like <code>Some(return)</code>, you would prefer that the type of this expression (if not otherwise constrained) is <code>Option&lt;!&gt;</code>, not <code>Option&lt;()&gt;</code>. In the case of <a href="https://github.com/rust-lang/rust/issues/66757">#66757</a>, we had similar code like <code>From::from(never)</code> where <code>never: Infallible</code>. If <code>Infallible</code> is an alias for <code>!</code>, this ought to &quot;fallback&quot; to <code>!</code>.</p>
<h2 id="proposal-fallback-chooses-between--and--based-on-the-coercion-graph"><a class="header" href="#proposal-fallback-chooses-between--and--based-on-the-coercion-graph">Proposal: fallback chooses between <code>()</code> and <code>!</code> based on the coercion graph</a></h2>
<p>So we've seen that changing the fallback <em>from</em> <code>()</code> causes unsoundness, but <em>keeping</em> the fallback as <code>!</code> can cause failed compilations. The proposal in this PR is to cause the fallback to be more subtle: diverging type variables prefer to fallback to <code>!</code> but <em>sometimes</em> fallback to <code>()</code> (in cases where they may leak out into live code, in particular).</p>
<p>The idea is based on a &quot;coercion graph&quot;. Roughly speaking, each type that an unbound type variable <code>?A</code> is coerced into another unbound type variable <code>?B</code>, we create a <code>Coercion(?A -&gt; ?B)</code> relation (instead of immediately falling back to subtyping). At the end of type-checking, we can take any such relations that remain (because neither <code>?A</code> nor <code>?B</code> was constrained to another type) and create a graph where an edge <code>?A -&gt; B</code> indicates that <code>?A</code> is coerced into <code>?B</code>.
Similarly, we can identify those type variables <code>?X</code> where we have a coercion <code>! -&gt; ?X</code>. We call those <em>diverging</em> type variables. Each <em>diverging</em> type variable will either fallback to <code>!</code> or <code>()</code> depending on the coercion graph:</p>
<ul>
<li>Let <code>D*</code> be the set of type variables that are reachable from a diverging type variable via edges in the coercion graph. These are therefore the variables where the <code>!</code> type &quot;flows into&quot; them (or would, if it didn't represent the result of a diverging execution). </li>
<li>Let <code>N</code> be the set of type variables that are (a) unresolved and (b) not a member of <code>D*</code>. </li>
<li>Let <code>N*</code> be the set of type variables that are reachable from <code>N</code>. </li>
<li>Each diverging type variable in <code>D</code> will fallback to <code>()</code> if it can reach a variable in <code>N*</code> in the coercion graph, and otherwise fallback to <code>!</code>. </li>
</ul>
<p>The intuition here is: if there is some group of unconstrained type variables <code>?X</code> that are all dominated in the coercion graph by the type <code>!</code>, then they fallback to <code>!</code>. If there are type variables in the coercion graph that are the <em>target</em> of a <code>!</code> coercion but <em>also</em> flow into variable that are the target of other coercions, they fallback to <code>()</code>. </p>
<h3 id="effect-on-66173"><a class="header" href="#effect-on-66173">Effect on <a href="https://github.com/rust-lang/rust/issues/66173">#66173</a></a></h3>
<p>Recall the example from <a href="https://github.com/rust-lang/rust/issues/66173">#66173</a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: /*?X*/ = match something() {
    pattern1 =&gt; Default::default(), // has type `?T`
    pattern2 =&gt; panic!(&quot;...&quot;), // has type `!`
}; // the match has type `?M`
<span class="boring">}
</span></code></pre></pre>
<p>Here we have a coercion graph as follows:</p>
<pre><code>?T -&gt; ?M
! -&gt; ?M
?M -&gt; ?X
</code></pre>
<p>In this case, applying the rules above:</p>
<ul>
<li>The set <code>D</code> of diverging variables is <code>[?M]</code></li>
<li>The set <code>D*</code> of variables reachable from <code>D</code> is <code>[?M, ?X]</code></li>
<li>The set <code>N</code> of non-diverging variables is <code>[?T]</code></li>
<li>The set <code>N*</code> of variables reachable from <code>N</code> is <code>[?X, ?X, ?T]</code></li>
<li>Since the diverging variable <code>?M</code> can reach a variable in <code>N*</code>, it falls back to <code>()</code>, and the unsoundness is averted.</li>
</ul>
<h3 id="effect-on-66757"><a class="header" href="#effect-on-66757">Effect on <a href="https://github.com/rust-lang/rust/issues/66757">#66757</a></a></h3>
<p>Recall this example much like <a href="https://github.com/rust-lang/rust/issues/66757">#66757</a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;?R as From&lt;?F&gt;&gt;::from(return)
<span class="boring">}
</span></code></pre></pre>
<p>Here we have a coercion graph as follows:</p>
<pre><code>! -&gt; ?F
</code></pre>
<p>In particular, the type of the argument is <code>?F</code> and it is the target of a coercion from <code>!</code> (the type of the <code>return</code> expression). Since <code>?F</code> is <em>only</em> reachable from a <code>!</code>, it falls back to <code>!</code> as desired.</p>
<h3 id="weird-cases"><a class="header" href="#weird-cases">Weird cases</a></h3>
<p>There are some &quot;weird cases&quot; where <code>()</code> fallback can result even in dead code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x;
x = return;
x = Default::default();
<span class="boring">}
</span></code></pre></pre>
<p>Here, the type <code>?X</code> of <code>x</code> will have an &quot;incoming edge&quot; from the result of <code>Default::default</code> which will cause it to fallback to <code>()</code>. Seems ok.</p>
<h3 id="backwards-incompatibilies"><a class="header" href="#backwards-incompatibilies">Backwards incompatibilies</a></h3>
<p>Changing the fallback from <em>always</em> preferring <code>()</code> to <em>sometimes</em> preferring <code>!</code> can still cause regressions:</p>
<pre><pre class="playground"><code class="language-rust">trait Foo { }
impl Foo for () { }
impl Foo for i32 { }
fn gimme&lt;F: Foo&gt;(f: F) { }
fn main() {
    gimme(return);
}
</code></pre></pre>
<p>Here, the type argument of <code>gimme(return)</code> will fallback to <code>!</code> and stop compiling. </p>
<p>It can also cause changes in behavior, though that is relatively difficult to engineer. An example might be:</p>
<pre><code>match true {
    true =&gt; Cell::new(Default::default()),
    false =&gt; Cell::new(return),
}
</code></pre>
<p>In this case, the type variable for <code>Default::default</code> is never directly coerced into the type variable for <code>return</code>, so the latter would still fallback to <code>!</code>. In this example that would cause a compilation failure but one could imagine variants, similar to #66173, which would be unsound. (It's worth noting that the lint which @blitzerr and I were experimenting with <em>would</em> detect cases like this, though unfortunately it also detected its fair share of false warnings.) </p>
<h2 id="future-extensions"><a class="header" href="#future-extensions">Future extensions</a></h2>
<p>I would like to deprecate the <code>()</code> fallback. I believe that these cases ought to be hand-annotated and are quite surprising. Consider Example 1 from <a href="https://github.com/rust-lang/rust/issues/66173#issuecomment-720527102">this github comment</a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parser.unexpected()?;
<span class="boring">}
</span></code></pre></pre>
<p>Here the <code>?</code> desugaring winds up causing this to fall back to <code>()</code>, but I think it should require manual annotation, as removing the <code>?</code> would require manual annotation. We can consider this separately but this branch should make it possible to do such a transition over an edition, perhaps.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rfc"><a class="header" href="#-rfc">‚ú® RFC</a></h1>
<ul>
<li>Feature Name: never_type, never_type_fallback</li>
<li>Start Date: TBD</li>
<li>RFC PR: Past <a href="https://github.com/rust-lang/rfcs/pull/1216">rust-lang/rfcs#1216</a></li>
<li>Rust Issue: TBD</li>
</ul>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>Promote <code>!</code> to be a full-fledged type equivalent to an <code>enum</code> with no variants,
and adjust default inference fallback to avoid breakage.</p>
<h1 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide level explanation</a></h1>
<p>While empty types exist already in Rust today, for example in the form of <code>enum Foo {}</code>, most Rust users will not be directly familiar with them, so this RFC
provides an explanation of the properties these types hold (and that <code>!</code> will
hold).</p>
<ul>
<li>
<p><strong>They never exist at runtime</strong>, because there is no way to create one.</p>
</li>
<li>
<p><strong>Code that handles them cannot execute</strong>, because there is no value that it
could execute with. Therefore, having an empty type in scope is a static
guarantee that a piece of code will never be run.</p>
</li>
<li>
<p><strong>They represent the return type of functions that don't return</strong>. For a
function that never returns, such as <code>std::process::exit</code>, the set of all
values it may return is the empty set. That is to say, the type of all
values it may return is the type of no inhabitants, ie. <code>Never</code> or anything
isomorphic to it. Similarly, they are the logical type for expressions that
never return to their caller such as <code>break</code>, <code>continue</code> and <code>return</code>.</p>
</li>
<li>
<p><strong>They can be converted to any other type</strong>.
To specify a function <code>A -&gt; B</code> we need to specify a return value in <code>B</code> for
every possible argument in <code>A</code>. For example, an expression that converts
<code>bool -&gt; T</code> needs to specify a return value for both possible arguments
<code>true</code> and <code>false</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo: &amp;'static str = match x {
  true  =&gt; &quot;some_value&quot;,
  false =&gt; &quot;some_other_value&quot;,
};
<span class="boring">}
</span></code></pre></pre>
<p>Likewise, an expression to convert <code>() -&gt; T</code> needs to specify one value,
the value corresponding to <code>()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo: &amp;'static str = match x {
  ()  =&gt; &quot;some_value&quot;,
};
<span class="boring">}
</span></code></pre></pre>
<p>And following this pattern, to convert <code>Never -&gt; T</code> we need to specify a
<code>T</code> for every possible <code>Never</code>. Of which there are none:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo: &amp;'static str = match x { };
<span class="boring">}
</span></code></pre></pre>
<p>Reading this, it may be tempting to ask the question &quot;what is the value of
<code>foo</code> then?&quot;. Remember that this depends on the value of <code>x</code>. As there are
no possible values of <code>x</code> it's a meaningless question and besides, the
fact that <code>x</code> has type <code>Never</code> gives us a static guarantee that the match
block will never be executed.</p>
</li>
</ul>
<p>Here's some example code that uses <code>Never</code>. This is legal rust code that you
can run today.</p>
<pre><pre class="playground"><code class="language-rust">use std::process::exit;

// Our empty type
enum Never {}

// A diverging function with an ordinary return type
fn wrap_exit() -&gt; Never {
    exit(0);
}

// we can use a `Never` value to diverge without using unsafe code or calling
// any diverging intrinsics
fn diverge_from_never(n: Never) -&gt; ! {
    match n {
    }
}

fn main() {
    let x: Never = wrap_exit();
    // `x` is in scope, everything below here is dead code.

    let y: String = match x {
        // no match cases as `!` is uninhabited
    };

    // we can still use `y` though
    println!(&quot;Our string is: {}&quot;, y);

    // we can use `x` to diverge
    diverge_from_never(x)
}
</code></pre></pre>
<p>This RFC proposes that we allow <code>!</code> to be used directly, as a type, rather than
using <code>Never</code> (or equivalent) in its place. Under this RFC, the above code
could more simply be written.</p>
<pre><pre class="playground"><code class="language-rust">use std::process::exit;

fn main() {
    let x: ! = exit(0);
    // `x` is in scope, everything below here is dead code.

    let y: String = match x {
        // no match cases as `Never` has no variants
    };

    // we can still use `y` though
    println!(&quot;Our string is: {}&quot;, y);

    // we can use `x` to diverge
    x
}
</code></pre></pre>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>There are several key motivators for adding <code>!</code>, despite the existence of empty
types in the language already.</p>
<h2 id="it-creates-a-standard-empty-type-for-use-throughout-rust-code"><a class="header" href="#it-creates-a-standard-empty-type-for-use-throughout-rust-code">It creates a standard empty type for use throughout Rust code</a></h2>
<p>Empty types are useful for more than just marking functions as diverging.
When used in an enum variant they prevent the variant from ever being
instantiated. One major use case for this is if a method needs to return a
<code>Result&lt;T, E&gt;</code> to satisfy a trait but we know that the method will always
succeed.</p>
<p>For example, here's a possible implementation of <code>FromStr</code> for <code>String</code> than
currently exists in <code>libstd</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FromStr for String {
    type Err = !;

    fn from_str(s: &amp;str) -&gt; Result&lt;String, !&gt; {
        Ok(String::from(s))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This result can then be safely unwrapped to a <code>String</code> without using
code-smelly things like <code>unreachable!()</code> which often mask bugs in code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r: Result&lt;String, !&gt; = FromStr::from_str(&quot;hello&quot;);
let s = match r {
    Ok(s)   =&gt; s,
    Err(e)  =&gt; match e {},
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Try</code> trait family is written with never type in mind, and currently
relies on the <code>enum Infallible {}</code> defined in libcore as a substitute.</p>
<p>Empty types can also be used when someone needs a dummy type to implement a
trait. Because <code>!</code> can be converted to any other type it has a trivial
implementation of any trait whose only associated items are non-static
methods. The impl simply matches on self for every method.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ToSocketAddr {
    fn to_socket_addr(&amp;self) -&gt; IoResult&lt;SocketAddr&gt;;
    fn to_socket_addr_all(&amp;self) -&gt; IoResult&lt;Vec&lt;SocketAddr&gt;&gt;;
}

impl ToSocketAddr for ! {
    fn to_socket_addr(&amp;self) -&gt; IoResult&lt;SocketAddr&gt; {
        match self {}
    }

    fn to_socket_addr_all(&amp;self) -&gt; IoResult&lt;Vec&lt;SocketAddr&gt;&gt; {
        match self {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>All possible implementations of this trait for <code>!</code> are equivalent. This is
because any two functions that take a <code>!</code> argument and return the same type
are equivalent - they return the same result for the same arguments and
have the same effects (because they are uncallable).</p>
<p>Suppose someone wants to call <code>fn foo&lt;T: SomeTrait&gt;(arg: Option&lt;T&gt;)</code> with
<code>None</code>. They need to choose a type for <code>T</code> so they can pass <code>None::&lt;T&gt;</code> as
the argument. However there may be no sensible default type to use for <code>T</code>
or, worse, they may not have any types at their disposal that implement
<code>SomeTrait</code>. As the user in this case is only using <code>None</code>, a sensible
choice for <code>T</code> would be a type such that <code>Option&lt;T&gt;</code> can ony be <code>None</code>, i.e.
it would be nice to use <code>!</code>.</p>
<p>While the trait author or user could define their own empty type and
implement the trait themselves, it is useful to avoid the hassle of needing
to import the appropriate type in order to specify it in cases like this.</p>
<h2 id="better-dead-code-detection"><a class="header" href="#better-dead-code-detection">Better dead code detection</a></h2>
<p>Consider the following code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let t = std::thread::spawn(|| panic!(&quot;nope&quot;));
t.join().unwrap();
println!(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Under this RFC: the closure body gets typed <code>!</code> instead of <code>()</code>, the <code>unwrap()</code>
gets typed <code>!</code>, and the <code>println!</code> will raise a dead code warning. This
requires a canonical empty type to fallback to for the type of expressions
like <code>panic!()</code>.</p>
<p>To be clear, <code>!</code> has a meaning in any situation that any other type does. A <code>!</code>
function argument makes a function uncallable, a <code>Vec&lt;!&gt;</code> is a vector that can
never contain an element, a <code>!</code> enum variant makes the variant guaranteed never
to occur and so forth. It might seem pointless to use a <code>!</code> function argument or
a <code>Vec&lt;!&gt;</code>, but that's no reason to disallow it. And generic code sometimes
requires it.</p>
<p>It's also worth noting that the <code>!</code> proposed here is <em>not</em> the bottom type that
used to exist in Rust in the very early days. Making <code>!</code> a subtype of all types
would greatly complicate things as it would require, for example, <code>Vec&lt;!&gt;</code> be a
subtype of <code>Vec&lt;T&gt;</code>. This <code>!</code> is simply an empty type (albeit one that can be
cast to any other type).</p>
<h1 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h1>
<p>Add a new primitive type <code>!</code> to Rust. <code>!</code> behaves like an empty enum except that
it can be implicitly cast to any other type. For example, code like the
following is acceptable:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r: Result&lt;i32, !&gt; = Ok(23);
let i = match r {
    Ok(i)   =&gt; i,
    Err(e)  =&gt; e, // e is cast to i32
}
<span class="boring">}
</span></code></pre></pre>
<p>We also adjust the type inference algorithm used by rustc to fallback to <code>!</code>
rather than <code>()</code> when an inference variable ends up unconstrained. This change
is motivated by the desire to provide a better experience for Rust users since
expressions typed at <code>!</code> can be coerced into other types. If we avoid making
this change, we have to specify that expressions like <code>loop {}</code> and <code>panic!()</code>
continue to &quot;return&quot; <code>()</code>, which seems obviously wrong.</p>
<p>Adjusting type inference to fallback to <code>!</code> also helps set us on a path towards
removing some of the fallback and <em>requiring</em> explicit types in the future, as
we can be more confident that the code involved is somewhat faulty.</p>
<h2 id="ensuring-soundness"><a class="header" href="#ensuring-soundness">Ensuring soundness</a></h2>
<p>However, this change to fallback is not generally sound in the presence of
unsafe code that is present in the wild today. The following is a piece of
example code that was previously OK, but with the proposed change has undefined
behavior.  It's a stripped down example -- the code is already unsound in the
sense that <code>unconstrained_return</code> must only be called with valid <code>T</code>, but in
practice code like this exists and does not cause UB (as it never gets
instantiated with an incorrect <code>T</code>) with today's compiler.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn unconstrained_return&lt;T&gt;() -&gt; Result&lt;T, String&gt; {
    let ffi: fn() -&gt; T = std::mem::transmute(some_pointer);
    Ok(ffi())
}

fn foo() {
    let _a = match unconstrained_return::&lt;_&gt;() {
        Ok(a) =&gt; a,
        Err(s) =&gt; panic!(&quot;failed to run&quot;),
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>The match here has type <code>?M</code> and the two arms have types <code>?T</code> and <code>!</code>, as
<code>panic!</code> has type <code>!</code> with these changes. <code>?T</code> here is effectively
unconstrained, so it falls back to <code>!</code> with the proposed change to type
inference. As a result, <code>unconstrained_return</code>'s call to <code>ffi()</code> has a return
type of <code>!</code>, which means that the compiler is free to assume that the function
does not return. Since <code>ffi()</code> in practice does return, this leads to UB.</p>
<p>So we cannot simply change fallback in all cases.</p>
<p>We propose an algorithm which indicates whether it is safe to fallback to <code>!</code>.</p>
<p>For each inference variable still present during fallback (i.e. those which are
unconstrained), we look at the relationships between these inference variables
to determine whether to keep the fallback to <code>()</code> or fallback to <code>!</code>.</p>
<p>We construct a directed graph where the vertices are inference variables, and
add edges <code>?A -&gt; ?B</code> if <code>?A</code> is coerced into <code>?B</code>.</p>
<p>Let <code>D</code> be the set of type variables <code>?X</code> which were created as a result of the
coercion of <code>! -&gt; ?X</code> being proposed. These can arise from functions returning
<code>!</code> or <code>loop {}</code> expressions, which can coerce into any type.</p>
<p>For each type variable <code>?T</code>, we fallback to:</p>
<ul>
<li><code>!</code> if the variable is dominated in the graph by the set <code>D</code> (that is, there
is no path from a non-diverging type variable to it).</li>
<li><code>()</code> otherwise.</li>
</ul>
<p>The intuition here is that variables reachable only from diverging type
variables must be in dead code, but if they are <em>also</em> reachable from some
non-diverging type variable, they may be in live code, and so fallback to <code>!</code> is
unsound.</p>
<h2 id="avoiding-regressions"><a class="header" href="#avoiding-regressions">Avoiding regressions</a></h2>
<p>The proposed graph is sufficient for soundness, but unfortunately is
insufficient to avoid a good number of regressions. We add an additional
heuristic that mitigates most of the remaining breakage (~100 crates per
Crater), leaving ~25 regressions.</p>
<p>This heuristic adds another case of fallback of <code>?T</code> to <code>()</code> when we encounter the
following:</p>
<ul>
<li><code>?T: Foo</code> and</li>
<li><code>Bar::Baz = ?T</code> and</li>
<li><code>(): Foo</code></li>
</ul>
<p>This pattern is commonly encountered in code which constrains the return type of
some closure, and where closure instances frequently contain <code>panic!()</code>. With
the previously proposed fallback, there is no additional constraint on <code>?T</code>
(it's not flowing into any other inference variables), so it is reasonable for
it to fallback to <code>!</code>. However, in practice, that causes breakage, as the
closure's return type is restricted to <code>Bar</code>, which is only implemented for <code>()</code>
(and <code>u32</code>).</p>
<pre><pre class="playground"><code class="language-rust">// Crate A:
pub trait Bar { }
impl Bar for () {  }
impl Bar for u32 {  }

pub fn foo&lt;R: Bar&gt;(_: impl Fn() -&gt; R) {}

// Crate B:
fn main() {
    foo(|| panic!());
}
</code></pre></pre>
<h1 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h1>
<h2 id="leave-infallible-as-the-standard-empty-type"><a class="header" href="#leave-infallible-as-the-standard-empty-type">Leave <code>Infallible</code> as the standard empty type</a></h2>
<p>We could abandon the effort to stabilize <code>!</code> as a dedicated return type, instead
leaving the currently existing <code>Infallible</code> as the standard empty type. There
are several downsides to this:</p>
<ul>
<li>Users need to learn two different canonical names (<code>!</code> if standalone in a function return
types and <code>Infallible</code> for other places)</li>
<li><code>Infallible</code> is either special-cased to coerce to other types or users need to
write <code>match foo {}</code> to get that behavior.</li>
</ul>
<h2 id="edition-based-fallback"><a class="header" href="#edition-based-fallback">Edition-based fallback?</a></h2>
<p>We considered whether the fallback algorithm could be adjusted over an edition
boundary to permit stabilizing never type. In practice, this doesn't work
because the never type is a vocabulary type and so is present in the public API
of various crates (including core/std, after stabilization).</p>
<p>This means that while the fallback within a library might be edition-dependent,
we'd still need to stabilize full use of <code>!</code> across all editions. That basically
puts prior editions on the same grounds as <em>just</em> stabilizing <code>!</code>, which is
known to introduce regressions.</p>
<p>Generally it seems pretty clear that stabilizing never type (or fallback
changes) only on a subset of editions would lead to a more challenging landscape
for Rust users. For example, as we've seen, fallback has implications for
soundness, so we'd still need all of the complexity in the fallback algorithm in
order to prevent cases like the one described above -- this seems to just make
things more complicated, rather than improving them.</p>
<h1 id="future-work"><a class="header" href="#future-work">Future work</a></h1>
<h2 id="removing-parts-of-fallback"><a class="header" href="#removing-parts-of-fallback">Removing (parts of) fallback</a></h2>
<p>We can consider removing some of the cases of fallback, particularly those which
cause problems for this RFC, in the future. There were several examples
encountered in Crater and elsewhere that required effort to deduce the inferred
type. Additionally, we believe that it's likely that cases of fallback to <code>()</code>
in new code are likely better written in other ways and we may wish to force the
user to indicate a type rather than silently providing one that may cause
trouble or hurt diagnostic quality.</p>
<p>We can leverage editions to remove parts of fallback. Unlike the phase-in of
never type fallback, <em>removing</em> fallback only prevents code from compiling and
does not change the behavior of existing code. This is fairly standard for
cross-edition changes, and so is much more straightforward to design.</p>
<p>However, this RFC does not propose a particular path towards removing/improving
our fallback algorithms, beyond noting that it may be advantageous to do so. If
we do so, we can likely end up avoiding the more complex fallback algorithm
proposed by this RFC being a permanent feature of future Rust editions.</p>
<h2 id="special-casing-trait-impls-for-"><a class="header" href="#special-casing-trait-impls-for-">Special casing trait impls for !</a></h2>
<p><code>!</code> is useful as a standard marker inside types which may derive various traits.
Implementing a trait for <code>!</code> is frequently fairly annoying, as you need to write
out many functions which are largely inconsequential as they can never run (if
they have a <code>self</code> parameter).</p>
<p>For now, the expectation is that library authors will want to add manual
impls for standard traits (including in the standard library), but a future
extension could let users write (potentially) overlapping trait impls for <code>!</code> so
long as the body of the trait is &quot;obviously equivalent&quot; as the methods can't be
called.</p>
<h1 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h1>
<ul>
<li>Pending (needs review of the above)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-frequently-asked-questions"><a class="header" href="#-frequently-asked-questions">üòï Frequently asked questions</a></h1>
<blockquote>
<p>This page lists frequently asked questions about the design. It often redirects to the other pages on the site.</p>
</blockquote>
<h2 id="what-is-the-goal-of-this-initiative"><a class="header" href="#what-is-the-goal-of-this-initiative">What is the goal of this initiative?</a></h2>
<p>See the <a href="./CHARTER.html">Charter</a>.</p>
<h2 id="who-is-working-on-it"><a class="header" href="#who-is-working-on-it">Who is working on it!</a></h2>
<p>See the <a href="./CHARTER.html">Charter</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
